
import { logger } from '@/utils/logging';
import { generateTemplateConfig, writeConfigToLocalStorage } from '@/services/site-config/site-config-file-service';
import { SiteConfigEnv } from '@/services/supabase/site-config-service';

/**
 * Enhanced configuration generator with better portability support
 */

export interface ConfigTransferOptions {
  includeSecrets?: boolean;
  format?: 'json' | 'env';
  targetEnvironment?: 'development' | 'production' | 'staging';
}

/**
 * Generate a configuration file with the provided values
 * Enhanced for better portability across environments
 */
export async function generateConfigFile(
  supabaseUrl: string,
  supabaseAnonKey: string,
  options: ConfigTransferOptions = {}
): Promise<boolean> {
  try {
    // Validate inputs
    if (!supabaseUrl || !supabaseAnonKey) {
      logger.error('Cannot generate config with empty values', {
        module: 'config-generator'
      });
      return false;
    }
    
    // Validate Supabase URL format for better portability
    if (!supabaseUrl.includes('.supabase.co') && !supabaseUrl.includes('localhost')) {
      logger.warn('Unusual Supabase URL format detected', {
        module: 'config-generator',
        url: supabaseUrl.substring(0, 20) + '...'
      });
    }
    
    const config = {
      ...generateTemplateConfig(),
      supabaseUrl: supabaseUrl.trim(),
      supabaseAnonKey: supabaseAnonKey.trim(),
      lastUpdated: new Date().toISOString(),
      environment: options.targetEnvironment || 'production',
      portabilityVersion: '1.0.0'
    };
    
    // Save to localStorage as a fallback
    const siteConfig: SiteConfigEnv = {
      supabaseUrl: config.supabaseUrl,
      supabaseAnonKey: config.supabaseAnonKey,
      siteHost: config.siteHost,
      lastUpdated: config.lastUpdated
    };
    
    writeConfigToLocalStorage(siteConfig);
    
    // Generate downloadable configuration based on format
    if (typeof window !== 'undefined') {
      let content: string;
      let filename: string;
      let mimeType: string;
      
      if (options.format === 'env') {
        // Generate .env format for easier deployment
        content = [
          '# Supabase Configuration',
          '# Generated by your application for portability',
          `VITE_SUPABASE_URL=${config.supabaseUrl}`,
          `VITE_SUPABASE_ANON_KEY=${config.supabaseAnonKey}`,
          `# Last updated: ${config.lastUpdated}`,
          `# Environment: ${config.environment}`
        ].join('\n');
        filename = '.env.example';
        mimeType = 'text/plain';
      } else {
        // Default JSON format
        content = JSON.stringify(config, null, 2);
        filename = 'site-config.json';
        mimeType = 'application/json';
      }
      
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      // Create a download link
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      
      // Clean up
      URL.revokeObjectURL(url);
      
      logger.info('Configuration file generated and downloaded', {
        module: 'config-generator',
        format: options.format || 'json',
        environment: options.targetEnvironment || 'production'
      });
      
      return true;
    }
    
    return true;
  } catch (error) {
    logger.error('Error generating configuration file', {
      module: 'config-generator',
      error: error instanceof Error ? error.message : String(error)
    });
    return false;
  }
}

/**
 * Enhanced configuration validation for cross-environment compatibility
 */
export function validateConfigForPortability(config: any): {
  isValid: boolean;
  warnings: string[];
  errors: string[];
} {
  const warnings: string[] = [];
  const errors: string[] = [];
  
  // Check required fields
  if (!config.supabaseUrl) {
    errors.push('Supabase URL is required');
  } else {
    // Validate URL format
    try {
      const url = new URL(config.supabaseUrl);
      if (!url.hostname.includes('supabase.co') && !url.hostname.includes('localhost')) {
        warnings.push('Non-standard Supabase URL detected - ensure this is correct for your target environment');
      }
    } catch {
      errors.push('Invalid Supabase URL format');
    }
  }
  
  if (!config.supabaseAnonKey) {
    errors.push('Supabase anonymous key is required');
  } else {
    // Basic JWT format validation
    const parts = config.supabaseAnonKey.split('.');
    if (parts.length !== 3) {
      errors.push('Supabase anonymous key does not appear to be a valid JWT');
    }
  }
  
  // Check for common portability issues
  if (config.siteHost && config.siteHost.includes('localhost')) {
    warnings.push('Configuration contains localhost URL - update for production deployment');
  }
  
  // Check for environment-specific settings
  if (!config.environment) {
    warnings.push('No environment specified - defaulting to production');
  }
  
  return {
    isValid: errors.length === 0,
    warnings,
    errors
  };
}

/**
 * Check if the current environment has valid configuration
 * Enhanced with better cross-environment detection
 */
export function hasValidConfiguration(): boolean {
  try {
    // Check environment variables
    const hasEnvVars = !!(
      import.meta.env.VITE_SUPABASE_URL && 
      import.meta.env.VITE_SUPABASE_ANON_KEY
    );
    
    // Check localStorage
    let hasLocalStorage = false;
    if (typeof localStorage !== 'undefined') {
      const configs = [
        localStorage.getItem('site-config'),
        localStorage.getItem('supabase_config'),
        localStorage.getItem('supabase-config')
      ];
      
      hasLocalStorage = configs.some(config => {
        if (!config) return false;
        try {
          const parsed = JSON.parse(config);
          return !!(parsed.supabaseUrl && parsed.supabaseAnonKey);
        } catch {
          return false;
        }
      });
    }
    
    // Check static file
    // Note: This is async, so we can't check it synchronously here
    
    return hasEnvVars || hasLocalStorage;
  } catch (error) {
    logger.error('Error checking configuration', {
      module: 'config-generator',
      error: error instanceof Error ? error.message : String(error)
    });
    return false;
  }
}

/**
 * Get detailed configuration status from all sources
 * This is useful for displaying to users
 */
export async function getConfigurationStatus(): Promise<{
  isValid: boolean;
  sources: {
    staticFile: boolean;
    localStorage: boolean;
    environment: boolean;
  };
  details: {
    staticFile: string | null;
    localStorage: string | null;
    environment: string | null;
  };
}> {
  try {
    // Check static file
    let staticFileConfig = null;
    try {
      const response = await fetch('/site-config.json', { 
        cache: 'no-store',
        headers: { 'Cache-Control': 'no-cache' }
      });
      if (response.ok) {
        const data = await response.json();
        staticFileConfig = data.supabaseUrl && data.supabaseAnonKey ? 
          `${data.supabaseUrl.substring(0, 15)}...` : null;
      }
    } catch (e) {
      // File not found or invalid
    }
    
    // Check localStorage
    let localStorageConfig = null;
    if (typeof localStorage !== 'undefined') {
      try {
        const data = localStorage.getItem('site-config');
        if (data) {
          const parsed = JSON.parse(data);
          localStorageConfig = parsed.supabaseUrl && parsed.supabaseAnonKey ? 
            `${parsed.supabaseUrl.substring(0, 15)}...` : null;
        }
      } catch (e) {
        // Invalid JSON
      }
    }
    
    // Check environment variables
    const envConfig = !!(
      import.meta.env.VITE_SUPABASE_URL && 
      import.meta.env.VITE_SUPABASE_ANON_KEY
    ) ? `${import.meta.env.VITE_SUPABASE_URL.substring(0, 15)}...` : null;
    
    const hasStaticFile = !!staticFileConfig;
    const hasLocalStorage = !!localStorageConfig;
    const hasEnvVars = !!envConfig;
    
    return {
      isValid: hasStaticFile || hasLocalStorage || hasEnvVars,
      sources: {
        staticFile: hasStaticFile,
        localStorage: hasLocalStorage,
        environment: hasEnvVars
      },
      details: {
        staticFile: staticFileConfig,
        localStorage: localStorageConfig,
        environment: envConfig
      }
    };
  } catch (error) {
    logger.error('Error getting configuration status', {
      module: 'config-generator',
      error: error instanceof Error ? error.message : String(error)
    });
    
    return {
      isValid: false,
      sources: {
        staticFile: false,
        localStorage: false,
        environment: false
      },
      details: {
        staticFile: null,
        localStorage: null,
        environment: null
      }
    };
  }
}
