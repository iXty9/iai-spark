import { logger } from '@/utils/logging';
import { generateTemplateConfig, writeConfigToLocalStorage } from '@/services/site-config/site-config-file-service';
import { SiteConfigEnv } from '@/services/supabase/site-config-service';

/**
 * Enhanced configuration generator with better portability support
 */
export interface ConfigTransferOptions {
  includeSecrets?: boolean;
  format?: 'json' | 'env';
  targetEnvironment?: 'development' | 'production' | 'staging';
}

/** Helper to get config from localStorage under common keys */
const getLocalConfig = (): any => {
  if (typeof localStorage === 'undefined') return null;
  for (const key of ['site-config', 'supabase_config', 'supabase-config']) {
    const val = localStorage.getItem(key);
    if (val) {
      try {
        const parsed = JSON.parse(val);
        if (parsed.supabaseUrl && parsed.supabaseAnonKey) return parsed;
      } catch {}
    }
  }
  return null;
};

/** Generate a config file (as .json or .env format), also updates localStorage */
export async function generateConfigFile(
  supabaseUrl: string,
  supabaseAnonKey: string,
  options: ConfigTransferOptions = {}
): Promise<boolean> {
  try {
    if (!supabaseUrl || !supabaseAnonKey) {
      logger.error('Cannot generate config with empty values', { module: 'config-generator' });
      return false;
    }
    if (!/(\.supabase\.co|localhost)/.test(supabaseUrl))
      logger.warn('Unusual Supabase URL format detected', {
        module: 'config-generator', url: supabaseUrl.substring(0, 20) + '...'
      });

    const config = {
      ...generateTemplateConfig(),
      supabaseUrl: supabaseUrl.trim(),
      supabaseAnonKey: supabaseAnonKey.trim(),
      lastUpdated: new Date().toISOString(),
      environment: options.targetEnvironment || 'production',
      portabilityVersion: '1.0.0'
    };

    // Keep localStorage site config updated
    writeConfigToLocalStorage({
      supabaseUrl: config.supabaseUrl,
      supabaseAnonKey: config.supabaseAnonKey,
      siteHost: config.siteHost,
      lastUpdated: config.lastUpdated
    });

    if (typeof window !== 'undefined') {
      let content = '', mime = '', name = '';
      if (options.format === 'env') {
        content = [
          '# Supabase Configuration',
          '# Generated by your application for portability',
          `VITE_SUPABASE_URL=${config.supabaseUrl}`,
          `VITE_SUPABASE_ANON_KEY=${config.supabaseAnonKey}`,
          `# Last updated: ${config.lastUpdated}`,
          `# Environment: ${config.environment}`
        ].join('\n');
        name = '.env.example'; mime = 'text/plain';
      } else {
        content = JSON.stringify(config, null, 2);
        name = 'site-config.json'; mime = 'application/json';
      }
      const a = Object.assign(document.createElement('a'), {
        href: URL.createObjectURL(new Blob([content], { type: mime })),
        download: name
      });
      a.click();
      URL.revokeObjectURL(a.href);
      logger.info('Configuration file generated and downloaded', {
        module: 'config-generator', format: options.format || 'json',
        environment: options.targetEnvironment || 'production'
      });
    }
    return true;
  } catch (error) {
    logger.error('Error generating configuration file', {
      module: 'config-generator',
      error: error instanceof Error ? error.message : String(error)
    });
    return false;
  }
}

/** Validate config for portablity across environments */
export function validateConfigForPortability(config: any): {
  isValid: boolean;
  warnings: string[];
  errors: string[];
} {
  const warnings: string[] = [], errors: string[] = [];
  if (!config.supabaseUrl) errors.push('Supabase URL is required');
  else {
    try {
      const url = new URL(config.supabaseUrl);
      if (!/supabase\.co|localhost/.test(url.hostname))
        warnings.push('Non-standard Supabase URL detected - ensure this is correct for your target environment');
    } catch { errors.push('Invalid Supabase URL format'); }
  }
  if (!config.supabaseAnonKey) errors.push('Supabase anonymous key is required');
  else if (config.supabaseAnonKey.split('.').length !== 3)
    errors.push('Supabase anonymous key does not appear to be a valid JWT');
  if (config.siteHost?.includes('localhost'))
    warnings.push('Configuration contains localhost URL - update for production deployment');
  if (!config.environment)
    warnings.push('No environment specified - defaulting to production');
  return { isValid: errors.length === 0, warnings, errors };
}

/** Check if config exists in environment, storage, or static file (synchronously) */
export function hasValidConfiguration(): boolean {
  try {
    const env = import.meta.env;
    const hasEnvVars = !!(env.VITE_SUPABASE_URL && env.VITE_SUPABASE_ANON_KEY);
    const hasLocalStorage = !!getLocalConfig();
    // static file check omitted as it's async
    return hasEnvVars || hasLocalStorage;
  } catch (e) {
    logger.error('Error checking configuration', { module: 'config-generator', error: e instanceof Error ? e.message : String(e) });
    return false;
  }
}

/** Get config present in static file, storage, env (details for UI) */
export async function getConfigurationStatus(): Promise<{
  isValid: boolean;
  sources: { staticFile: boolean; localStorage: boolean; environment: boolean; };
  details: { staticFile: string | null; localStorage: string | null; environment: string | null; };
}> {
  try {
    let staticConf: string | null = null;
    try {
      const r = await fetch('/site-config.json', { cache: 'no-store', headers: { 'Cache-Control': 'no-cache' } });
      if (r.ok) {
        const d = await r.json();
        staticConf = d.supabaseUrl && d.supabaseAnonKey ? `${d.supabaseUrl.substring(0, 15)}...` : null;
      }
    } catch {}
    const localConfig = getLocalConfig();
    const localConf = localConfig ? `${localConfig.supabaseUrl.substring(0, 15)}...` : null;
    const env = import.meta.env;
    const envConf = (env.VITE_SUPABASE_URL && env.VITE_SUPABASE_ANON_KEY)
      ? `${env.VITE_SUPABASE_URL.substring(0, 15)}...` : null;
    return {
      isValid: !!(staticConf || localConf || envConf),
      sources: { staticFile: !!staticConf, localStorage: !!localConf, environment: !!envConf },
      details: { staticFile: staticConf, localStorage: localConf, environment: envConf }
    };
  } catch (error) {
    logger.error('Error getting configuration status', {
      module: 'config-generator',
      error: error instanceof Error ? error.message : String(error)
    });
    return {
      isValid: false,
      sources: { staticFile: false, localStorage: false, environment: false },
      details: { staticFile: null, localStorage: null, environment: null }
    };
  }
}