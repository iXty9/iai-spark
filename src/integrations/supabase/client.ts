
// This file is automatically generated from the connection service.
// Do not edit it directly.

import { getSupabaseClient } from '@/services/supabase/connection-service';
import { toast } from '@/hooks/use-toast';
import { PostgrestResponse, PostgrestSingleResponse } from '@supabase/supabase-js';
import { emitSupabaseConnectionEvent } from '@/utils/debug';

// Initialize client as null, will be set properly after bootstrap
let client = null;

// Attempt to get the client immediately
client = getSupabaseClient();

// If client isn't available, try again after a delay to allow bootstrap to complete
if (!client) {
  setTimeout(() => {
    client = getSupabaseClient();
    
    // Emit connection status after delayed initialization
    if (client) {
      emitSupabaseConnectionEvent('connected', null);
    } else {
      emitSupabaseConnectionEvent('disconnected', 'Client not initialized after retry');
    }
  }, 1500); // Give bootstrap enough time to complete
} else {
  // Emit connection status for debugging if client is available immediately
  emitSupabaseConnectionEvent('connected', null);
}

// Fallback client for handling cases when the Supabase client isn't available
const fallbackClient = {
  auth: {
    getSession: () => {
      // Track connection error for debugging
      emitSupabaseConnectionEvent('auth_error', 'Client not initialized');
      
      toast({
        title: 'Connection Error',
        description: 'Supabase client is not available. Please check configuration or reconnect.',
        variant: 'destructive',
        action: {
          altText: "Reconnect",
          onClick: () => window.location.href = '/supabase-auth'
        }
      });
      return Promise.resolve({ data: { session: null }, error: new Error('Client not initialized') });
    },
    signOut: () => Promise.resolve({ error: new Error('Client not initialized') }),
    signInWithPassword: () => Promise.resolve({ data: { user: null, session: null }, error: new Error('Client not initialized') }),
    onAuthStateChange: () => ({ data: { subscription: { unsubscribe: () => {} } } }),
    signUp: () => Promise.resolve({ data: { user: null, session: null }, error: new Error('Client not initialized') }),
    getUser: () => Promise.resolve({ data: { user: null }, error: new Error('Client not initialized') })
  },
  from: (table: string) => ({
    select: (columns?: string) => {
      // Create properly typed return object
      const responseObj: any = {
        eq: (column: string, value: any) => Promise.resolve({ 
          data: null, 
          error: new Error('Client not initialized'),
          count: null
        }),
        neq: () => responseObj,
        gt: () => responseObj,
        lt: () => responseObj,
        gte: () => responseObj,
        lte: () => responseObj,
        like: () => responseObj,
        ilike: () => responseObj,
        is: () => responseObj,
        in: () => responseObj,
        contains: () => responseObj,
        containedBy: () => responseObj,
        filter: () => responseObj,
        match: () => responseObj,
        single: () => Promise.resolve({ 
          data: null, 
          error: new Error('Client not initialized'),
          count: null
        }),
        maybeSingle: () => Promise.resolve({ 
          data: null, 
          error: new Error('Client not initialized'),
          count: null
        }),
        order: () => responseObj,
        limit: () => responseObj,
        range: () => responseObj,
      };
      return responseObj;
    },
    insert: () => Promise.resolve({
      data: null,
      error: new Error('Client not initialized')
    }),
    update: () => ({
      eq: () => Promise.resolve({
        data: null,
        error: new Error('Client not initialized')
      }),
      match: () => Promise.resolve({
        data: null,
        error: new Error('Client not initialized')
      })
    }),
    delete: () => ({
      eq: () => Promise.resolve({
        data: null,
        error: new Error('Client not initialized')
      }),
      match: () => Promise.resolve({
        data: null,
        error: new Error('Client not initialized')
      })
    }),
    rpc: () => Promise.resolve({
      data: null,
      error: new Error('Client not initialized')
    })
  }),
  storage: {
    from: (bucket: string) => ({
      upload: () => Promise.resolve({ data: null, error: new Error('Client not initialized') }),
      getPublicUrl: () => ({ data: { publicUrl: '' } }),
      list: () => Promise.resolve({ data: null, error: new Error('Client not initialized') }),
      remove: () => Promise.resolve({ data: null, error: new Error('Client not initialized') }),
    }),
    getBucket: () => Promise.resolve({ data: null, error: new Error('Client not initialized') }),
    createBucket: () => Promise.resolve({ data: null, error: new Error('Client not initialized') }),
  },
  functions: {
    invoke: () => Promise.resolve({
      data: null,
      error: new Error('Client not initialized'),
      status: 500,
      count: null
    })
  }
};

// Export a function that always returns the latest client
// This ensures we always get the most up-to-date client instance
export const supabase = (() => {
  return function getClient() {
    // If client exists, return it
    if (client) return client;
    
    // Try to get the client again
    const freshClient = getSupabaseClient();
    if (freshClient) {
      client = freshClient;
      return client;
    }
    
    // Fall back to the fallback client if still no client
    return fallbackClient;
  };
})()();
